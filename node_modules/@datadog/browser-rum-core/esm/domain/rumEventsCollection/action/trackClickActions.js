import { timeStampNow, isExperimentalFeatureEnabled, Observable, assign, getRelativeTime, ONE_MINUTE, ContextHistory, generateUUID, clocksNow, ONE_SECOND, elapsed, } from '@datadog/browser-core';
import { trackEventCounts } from '../../trackEventCounts';
import { waitPageActivityEnd } from '../../waitPageActivityEnd';
import { createClickChain } from './clickChain';
import { getActionNameFromElement } from './getActionNameFromElement';
import { getSelectorsFromElement } from './getSelectorsFromElement';
import { listenActionEvents } from './listenActionEvents';
import { computeFrustration } from './computeFrustration';
// Maximum duration for click actions
export var CLICK_ACTION_MAX_DURATION = 10 * ONE_SECOND;
export var ACTION_CONTEXT_TIME_OUT_DELAY = 5 * ONE_MINUTE; // arbitrary
export function trackClickActions(lifeCycle, domMutationObservable, configuration) {
    var history = new ContextHistory(ACTION_CONTEXT_TIME_OUT_DELAY);
    var stopObservable = new Observable();
    var trackFrustrations = configuration.trackFrustrations;
    var currentClickChain;
    lifeCycle.subscribe(8 /* SESSION_RENEWED */, function () {
        history.reset();
    });
    lifeCycle.subscribe(9 /* BEFORE_UNLOAD */, stopClickChain);
    lifeCycle.subscribe(4 /* VIEW_ENDED */, stopClickChain);
    var stopActionEventsListener = listenActionEvents({ onClick: processClick }).stop;
    var actionContexts = {
        findActionId: function (startTime) {
            return trackFrustrations ? history.findAll(startTime) : history.find(startTime);
        },
    };
    return {
        stop: function () {
            stopClickChain();
            stopObservable.notify();
            stopActionEventsListener();
        },
        actionContexts: actionContexts,
    };
    function stopClickChain() {
        if (currentClickChain) {
            currentClickChain.stop();
        }
    }
    function processClick(_a) {
        var event = _a.event, getUserActivity = _a.getUserActivity;
        if (!trackFrustrations && history.find()) {
            // TODO: remove this in a future major version. To keep retrocompatibility, ignore any new
            // action if another one is already occurring.
            return;
        }
        var clickActionBase = computeClickActionBase(event, configuration.actionNameAttribute);
        if (!trackFrustrations && !clickActionBase.name) {
            // TODO: remove this in a future major version. To keep retrocompatibility, ignore any action
            // with a blank name
            return;
        }
        var click = newClick(lifeCycle, history, getUserActivity, clickActionBase);
        if (trackFrustrations && (!currentClickChain || !currentClickChain.tryAppend(click))) {
            var rageClick_1 = click.clone();
            currentClickChain = createClickChain(click, function (clicks) {
                finalizeClicks(clicks, rageClick_1);
            });
        }
        var stopWaitPageActivityEnd = waitPageActivityEnd(lifeCycle, domMutationObservable, configuration, function (pageActivityEndEvent) {
            if (pageActivityEndEvent.hadActivity && pageActivityEndEvent.end < clickActionBase.startClocks.timeStamp) {
                // If the clock is looking weird, just discard the click
                click.discard();
            }
            else {
                click.stop(pageActivityEndEvent.hadActivity ? pageActivityEndEvent.end : undefined);
                // Validate or discard the click only if we don't track frustrations. It'll be done when
                // the click chain is finalized.
                if (!trackFrustrations) {
                    if (!pageActivityEndEvent.hadActivity) {
                        // If we are not tracking frustrations, we should discard the click to keep backward
                        // compatibility.
                        click.discard();
                    }
                    else {
                        click.validate();
                    }
                }
            }
        }, CLICK_ACTION_MAX_DURATION).stop;
        var viewEndedSubscription = lifeCycle.subscribe(4 /* VIEW_ENDED */, function (_a) {
            var endClocks = _a.endClocks;
            click.stop(endClocks.timeStamp);
        });
        var stopSubscription = stopObservable.subscribe(function () {
            click.stop();
        });
        click.stopObservable.subscribe(function () {
            viewEndedSubscription.unsubscribe();
            stopWaitPageActivityEnd();
            stopSubscription.unsubscribe();
        });
    }
}
function computeClickActionBase(event, actionNameAttribute) {
    var target;
    var position;
    if (isExperimentalFeatureEnabled('clickmap')) {
        var rect = event.target.getBoundingClientRect();
        target = assign({
            width: Math.round(rect.width),
            height: Math.round(rect.height),
        }, getSelectorsFromElement(event.target, actionNameAttribute));
        position = {
            // Use clientX and Y because for SVG element offsetX and Y are relatives to the <svg> element
            x: Math.round(event.clientX - rect.left),
            y: Math.round(event.clientY - rect.top),
        };
    }
    return {
        type: 'click',
        target: target,
        position: position,
        name: getActionNameFromElement(event.target, actionNameAttribute),
        event: event,
        startClocks: clocksNow(),
    };
}
function newClick(lifeCycle, history, getUserActivity, clickActionBase) {
    var id = generateUUID();
    var historyEntry = history.add(id, clickActionBase.startClocks.relative);
    var eventCountsSubscription = trackEventCounts(lifeCycle);
    var status = 0 /* ONGOING */;
    var activityEndTime;
    var frustrationTypes = [];
    var stopObservable = new Observable();
    function stop(newActivityEndTime) {
        if (status !== 0 /* ONGOING */) {
            return;
        }
        activityEndTime = newActivityEndTime;
        status = 1 /* STOPPED */;
        if (activityEndTime) {
            historyEntry.close(getRelativeTime(activityEndTime));
        }
        else {
            historyEntry.remove();
        }
        eventCountsSubscription.stop();
        stopObservable.notify();
    }
    return {
        event: clickActionBase.event,
        stop: stop,
        stopObservable: stopObservable,
        get hasError() {
            return eventCountsSubscription.eventCounts.errorCount > 0;
        },
        get hasPageActivity() {
            return activityEndTime !== undefined;
        },
        getUserActivity: getUserActivity,
        addFrustration: function (frustrationType) {
            frustrationTypes.push(frustrationType);
        },
        isStopped: function () { return status === 1 /* STOPPED */ || status === 2 /* FINALIZED */; },
        clone: function () { return newClick(lifeCycle, history, getUserActivity, clickActionBase); },
        validate: function (domEvents) {
            stop();
            if (status !== 1 /* STOPPED */) {
                return;
            }
            var _a = eventCountsSubscription.eventCounts, resourceCount = _a.resourceCount, errorCount = _a.errorCount, longTaskCount = _a.longTaskCount;
            var clickAction = assign({
                type: "click" /* CLICK */,
                duration: activityEndTime && elapsed(clickActionBase.startClocks.timeStamp, activityEndTime),
                id: id,
                frustrationTypes: frustrationTypes,
                counts: {
                    resourceCount: resourceCount,
                    errorCount: errorCount,
                    longTaskCount: longTaskCount,
                },
                events: domEvents !== null && domEvents !== void 0 ? domEvents : [clickActionBase.event],
            }, clickActionBase);
            lifeCycle.notify(1 /* AUTO_ACTION_COMPLETED */, clickAction);
            status = 2 /* FINALIZED */;
        },
        discard: function () {
            stop();
            status = 2 /* FINALIZED */;
        },
    };
}
export function finalizeClicks(clicks, rageClick) {
    var isRage = computeFrustration(clicks, rageClick).isRage;
    if (isRage) {
        clicks.forEach(function (click) { return click.discard(); });
        rageClick.stop(timeStampNow());
        rageClick.validate(clicks.map(function (click) { return click.event; }));
    }
    else {
        rageClick.discard();
        clicks.forEach(function (click) { return click.validate(); });
    }
}
//# sourceMappingURL=trackClickActions.js.map